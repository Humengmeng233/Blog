import{_ as i,c as e,b as s,o as n}from"./app-B-WzGfHg.js";const l={};function t(p,a){return n(),e("div",null,a[0]||(a[0]=[s(`<h3 id="first-java" tabindex="-1"><a class="header-anchor" href="#first-java"><span>first Java</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span> public class Main{  </span></span>
<span class="line"><span>     public static void main(String[] args) {  </span></span>
<span class="line"><span>         System.out.println(&quot;Hello World&quot;);  </span></span>
<span class="line"><span>     }  </span></span>
<span class="line"><span> }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="声明变量" tabindex="-1"><a class="header-anchor" href="#声明变量"><span>声明变量</span></a></h4><p>和C语言规则一样，int a; 有时候我们希望变量的值一直保持不变，我们就可以将其指定为常量，这里我们介绍Java中第一个需要认识的关键字：</p><p>final int a = 666;   //在变量前面添加final关键字，表示这是一个常量,常量的值不允许发生修改</p><h4 id="计算机中二进制表示" tabindex="-1"><a class="header-anchor" href="#计算机中二进制表示"><span>计算机中二进制表示</span></a></h4><ul><li><p>1+1 = 10 （满二进一）=2^1+0</p></li><li><p>一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，一般采用字节来描述数据大小</p></li><li><p>1111=2+4+8+16</p></li><li><p>1024B=1KB，MB,GB,TB</p></li><li><p>在Java中，无论是小数还是整数，他们都要带有符号（和C语言不同，C语言有无符号数）所以，首位就作为我们的符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）：</p><ul><li><p>正数：0开头，0101 = 5</p></li><li><p>负数：1011 = 3</p></li></ul><h5 id="做加减法" tabindex="-1"><a class="header-anchor" href="#做加减法"><span>做加减法</span></a></h5><h6 id="引入反码" tabindex="-1"><a class="header-anchor" href="#引入反码"><span>引入反码</span></a></h6><ul><li><p>正数的反码就是其原码本身</p></li><li><p>负数的反码是原码的基础上，符号位不变，其余各位取反1001-&gt;1110 = -1</p></li></ul><p>直接进行加减法：1+(-1) = 0001 +1110 =&gt;-0</p><p>思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？0既不是正数也不是负数，那么显然这样的表示依然不够合理！根据上面的问题，我们引入了最终的解决方案，那就是</p><p><strong>补码</strong>，定义如下：</p><ul><li><p>正数的补码就是其本身 （不变！）0001-&gt;0001</p></li><li><p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1（即在反码的基础上+1，此时1000表示-8）</p></li><li><p>对补码再求一次补码就可得该补码对应的原码。</p></li></ul><p>比如-7原码为1111，反码为1000，补码就是1001了，-6原码为1110，反码为1001，补码就是1010。所以在补码下，原本的1000就作为新增的最小值-8存在。</p><p>所以现在-0没有了</p><ul><li>1+(-1) = 0001+1111 =1 0000 = + 0</li></ul></li></ul>`,7)]))}const d=i(l,[["render",t]]),c=JSON.parse('{"path":"/article/x9gvok5w/","title":"Java","lang":"zh-CN","frontmatter":{"title":"Java","tags":["java"],"createTime":"2025/07/30 19:08:56","permalink":"/article/x9gvok5w/"},"readingTime":{"minutes":1.91,"words":574},"git":{"createdTime":1755792434000,"updatedTime":1755792434000,"contributors":[{"name":"mengmeng","username":"mengmeng","email":"15314326450@163.com","commits":1,"avatar":"https://avatars.githubusercontent.com/mengmeng?v=4","url":"https://github.com/mengmeng"}]},"filePathRelative":"preview/Java.md","headers":[],"categoryList":[{"id":"5ebeb6","sort":10000,"name":"preview"}]}');export{d as comp,c as data};
